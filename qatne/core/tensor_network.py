"""\nAdaptive Tensor Network for quantum state representation.\n\nImplements Matrix Product State with dynamic bond dimension adaptation.\n"""\n\nimport numpy as np\nfrom typing import List, Tuple\n\n\nclass TensorNetwork:\n    \"\"\"\n    Adaptive Matrix Product State representation\n    \n    Maintains a tensor network structure that adapts based on\n    entanglement requirements during optimization.\n    \"\"\"\n    \n    def __init__(\n        self, \n        num_sites: int, \n        bond_dim: int = 4,\n        max_bond_dim: int = 32\n    ):\n        self.num_sites = num_sites\n        self.bond_dim = bond_dim\n        self.max_bond_dim = max_bond_dim\n        self.num_layers = self._compute_num_layers()\n        \n        # Store bond dimensions for each connection\n        self.bond_dims = {\n            (i, i+1): bond_dim \n            for i in range(num_sites - 1)\n        }\n        \n        # Entanglement structure\n        self.entanglement_pairs = self._initialize_entanglement()\n    \n    def _compute_num_layers(self) -> int:\n        \"\"\"Compute number of layers based on connectivity\"\"\"\n        return int(np.ceil(np.log2(self.num_sites))) + 1\n    \n    def _initialize_entanglement(self) -> List[List[Tuple[int, int]]]:\n        \"\"\"Initialize entanglement pairs for each layer\"\"\"\n        pairs_by_layer = []\n        \n        for layer in range(self.num_layers):\n            pairs = []\n            if layer % 2 == 0:\n                # Even layers: nearest neighbor\n                for i in range(0, self.num_sites - 1, 2):\n                    pairs.append((i, i + 1))\n            else:\n                # Odd layers: offset nearest neighbor\n                for i in range(1, self.num_sites - 1, 2):\n                    pairs.append((i, i + 1))\n            \n            pairs_by_layer.append(pairs)\n        \n        return pairs_by_layer\n    \n    def get_entanglement_pairs(self, layer: int) -> List[Tuple[int, int]]:\n        \"\"\"Get entanglement pairs for specific layer\"\"\"\n        if layer < len(self.entanglement_pairs):\n            return self.entanglement_pairs[layer]\n        return []\n    \n    def increase_bond_dim(self, site: int):\n        \"\"\"Increase bond dimension at specific site\"\"\"\n        if site < self.num_sites - 1:\n            current_dim = self.bond_dims.get((site, site + 1), self.bond_dim)\n            new_dim = min(current_dim * 2, self.max_bond_dim)\n            self.bond_dims[(site, site + 1)] = new_dim\n            \n            # Update overall bond dimension\n            self.bond_dim = max(self.bond_dims.values())\n    \n    def get_bond_dim(self, site: int) -> int:\n        \"\"\"Get bond dimension at specific site\"\"\"\n        return self.bond_dims.get((site, site + 1), self.bond_dim)\n    \n    def compute_entanglement_entropy(\n        self, \n        state_vector: np.ndarray, \n        partition: int\n    ) -> float:\n        \"\"\"\n        Compute von Neumann entanglement entropy across partition\n        \n        S = -Tr(ρ_A log ρ_A)\n        \"\"\"\n        n = int(np.log2(len(state_vector)))\n        \n        # Reshape to matrix for partial trace\n        state_matrix = state_vector.reshape(2**partition, 2**(n-partition))\n        \n        # Compute reduced density matrix\n        rho_A = state_matrix @ state_matrix.conj().T\n        \n        # Compute eigenvalues\n        eigenvalues = np.linalg.eigvalsh(rho_A)\n        \n        # Filter out near-zero eigenvalues\n        eigenvalues = eigenvalues[eigenvalues > 1e-12]\n        \n        # Compute entropy\n        entropy = -np.sum(eigenvalues * np.log2(eigenvalues))\n        \n        return entropy\n    \n    def truncate(self, threshold: float = 1e-10):\n        \"\"\"Truncate small bond dimensions to reduce complexity\"\"\"\n        for key in list(self.bond_dims.keys()):\n            if self.bond_dims[key] < threshold * self.max_bond_dim:\n                self.bond_dims[key] = max(2, self.bond_dims[key] // 2)\n    \n    def get_complexity(self) -> int:\n        \"\"\"\n        Compute computational complexity of tensor network\n        \n        Returns:\n            Total number of parameters in tensor network\n        \"\"\"\n        complexity = 0\n        for (i, j), bond_dim in self.bond_dims.items():\n            # Each bond contributes bond_dim^2 parameters\n            complexity += bond_dim ** 2\n        return complexity\n    \n    def visualize_structure(self) -> str:\n        \"\"\"\n        Create ASCII visualization of tensor network structure\n        \n        Returns:\n            String representation of network topology\n        \"\"\"\n        lines = []\n        lines.append(\"\\nTensor Network Structure:\")\n        lines.append(\"=\" * 40)\n        \n        for layer in range(self.num_layers):\n            pairs = self.get_entanglement_pairs(layer)\n            pair_str = \", \".join([f\"({i},{j})\" for i, j in pairs])\n            lines.append(f\"Layer {layer}: {pair_str}\")\n        \n        lines.append(\"\\nBond Dimensions:\")\n        for (i, j), dim in sorted(self.bond_dims.items()):\n            lines.append(f\"  Site {i}-{j}: χ = {dim}\")\n        \n        lines.append(f\"\\nTotal complexity: {self.get_complexity()} parameters\")\n        \n        return \"\\n\".join(lines)\n